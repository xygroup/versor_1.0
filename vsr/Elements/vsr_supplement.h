//
//  vsr_supplement.h
//  Versor
//
//  Created by Pablo Colapinto on 3/9/13.
//  Copyright (c) 2013 __MyCompanyName__. All rights reserved.
//

/*

    SUPPLEMENTARY OPERATIONS (PENDING A REFACTORING)

*/

#ifndef Versor_vsr_supplement_h
#define Versor_vsr_supplement_h

#include "vsr_casts.h"

namespace vsr {

//////////////////SUPPLEMENTS / EXTENDORS (group theory)
typedef Lin_Flp Gld;

inline Gld reverse(const Gld& a) {
  return Gld(a[0], a[1], a[2], a[3], -a[4], -a[5], -a[6]);
}

template <>
inline Mot sp(const Mot& mot, const Gld& lnf) {
  const Gld& t1 = lnf;
  const Mot& t2 = mot;
  Mot t3 = t2;  // involute( t2);
  Lin_Pln t4(t1[0] * t3[0] - t1[1] * t3[1] - t1[2] * t3[2],
             t1[0] * t3[1] + t1[1] * t3[0] - t1[2] * t3[3],
             t1[0] * t3[2] + t1[1] * t3[3] + t1[2] * t3[0],
             t1[0] * t3[4] + t1[1] * t3[5] + t1[2] * t3[6] + t1[3] * t3[0] -
                 t1[4] * t3[1] - t1[5] * t3[2] - t1[6] * t3[3],
             t1[0] * t3[5] - t1[1] * t3[4] + t1[2] * t3[7] + t1[3] * t3[1] +
                 t1[4] * t3[0] - t1[5] * t3[3] + t1[6] * t3[2],
             t1[0] * t3[6] - t1[1] * t3[7] - t1[2] * t3[4] + t1[3] * t3[2] +
                 t1[4] * t3[3] + t1[5] * t3[0] - t1[6] * t3[1],
             t1[0] * t3[7] + t1[1] * t3[6] - t1[2] * t3[5] + t1[3] * t3[3] -
                 t1[4] * t3[2] + t1[5] * t3[1] + t1[6] * t3[0],
             t1[0] * t3[3] - t1[1] * t3[2] + t1[2] * t3[1]);
  const Gld& t5 = lnf;
  Gld t6 = reverse(t5);
  return Mot(t4[0] * t6[0] + t4[1] * t6[1] + t4[2] * t6[2],
             t4[0] * t6[1] - t4[1] * t6[0] + t4[7] * t6[2],
             t4[0] * t6[2] - t4[2] * t6[0] - t4[7] * t6[1],
             t4[1] * t6[2] - t4[2] * t6[1] + t4[7] * t6[0],
             t4[0] * t6[3] - t4[1] * t6[4] - t4[2] * t6[5] - t4[3] * t6[0] -
                 t4[4] * t6[1] - t4[5] * t6[2] - t4[7] * t6[6],
             t4[0] * t6[4] + t4[1] * t6[3] - t4[2] * t6[6] - t4[3] * t6[1] +
                 t4[4] * t6[0] - t4[6] * t6[2] + t4[7] * t6[5],
             t4[0] * t6[5] + t4[1] * t6[6] + t4[2] * t6[3] - t4[3] * t6[2] +
                 t4[5] * t6[0] + t4[6] * t6[1] - t4[7] * t6[4],
             t4[0] * t6[6] - t4[1] * t6[5] + t4[2] * t6[4] - t4[4] * t6[2] +
                 t4[5] * t6[1] - t4[6] * t6[0] + t4[7] * t6[3]);
}

// Glide Reflection
template <>
inline Par re(const Par& par, const Gld& gld) {
  const Gld& t1 = gld;
  const Par& t2 = par;
  Par t3 = t2;  // involute( t2);
  Rtc t4(-t1[1] * t3[0] - t1[2] * t3[1] + t1[3] * t3[3] + t1[4] * t3[4] +
             t1[5] * t3[5],
         t1[0] * t3[0] - t1[2] * t3[2] + t1[3] * t3[4] - t1[4] * t3[3] +
             t1[6] * t3[5],
         t1[0] * t3[1] + t1[1] * t3[2] + t1[3] * t3[5] - t1[5] * t3[3] -
             t1[6] * t3[4],
         t1[0] * t3[3] + t1[1] * t3[4] + t1[2] * t3[5],
         t1[0] * t3[6] + t1[1] * t3[7] + t1[2] * t3[8] - t1[3] * t3[9] -
             t1[4] * t3[0] - t1[5] * t3[1] - t1[6] * t3[2],
         t1[0] * t3[4] - t1[1] * t3[3], t1[0] * t3[5] - t1[2] * t3[3],
         t1[1] * t3[5] - t1[2] * t3[4],
         t1[0] * t3[7] - t1[1] * t3[6] + t1[3] * t3[0] - t1[4] * t3[9] -
             t1[5] * t3[2] + t1[6] * t3[1],
         t1[0] * t3[8] - t1[2] * t3[6] + t1[3] * t3[1] + t1[4] * t3[2] -
             t1[5] * t3[9] - t1[6] * t3[0],
         t1[1] * t3[8] - t1[2] * t3[7] + t1[3] * t3[2] - t1[4] * t3[1] +
             t1[5] * t3[0] - t1[6] * t3[9],
         t1[0] * t3[9] + t1[3] * t3[3] + t1[4] * t3[4] + t1[5] * t3[5],
         t1[1] * t3[9] + t1[3] * t3[4] - t1[4] * t3[3] + t1[6] * t3[5],
         t1[2] * t3[9] + t1[3] * t3[5] - t1[5] * t3[3] - t1[6] * t3[4],
         t1[0] * t3[2] - t1[1] * t3[1] + t1[2] * t3[0] + t1[4] * t3[5] -
             t1[5] * t3[4] + t1[6] * t3[3],
         t1[4] * t3[5] - t1[5] * t3[4] + t1[6] * t3[3]);
  const Gld& t5 = gld;
  Gld t6 = reverse(t5);
  return Par(
      t4[0] * t6[1] - t4[1] * t6[0] - t4[3] * t6[4] - t4[5] * t6[3] +
          t4[6] * t6[6] - t4[7] * t6[5] + t4[14] * t6[2],
      t4[0] * t6[2] - t4[2] * t6[0] - t4[3] * t6[5] - t4[5] * t6[6] -
          t4[6] * t6[3] + t4[7] * t6[4] - t4[14] * t6[1],
      t4[1] * t6[2] - t4[2] * t6[1] - t4[3] * t6[6] + t4[5] * t6[5] -
          t4[6] * t6[4] - t4[7] * t6[3] + t4[14] * t6[0],
      -t4[3] * t6[0] - t4[5] * t6[1] - t4[6] * t6[2],
      -t4[3] * t6[1] + t4[5] * t6[0] - t4[7] * t6[2],
      -t4[3] * t6[2] + t4[6] * t6[0] + t4[7] * t6[1],
      t4[0] * t6[3] - t4[1] * t6[4] - t4[2] * t6[5] - t4[4] * t6[0] -
          t4[8] * t6[1] - t4[9] * t6[2] + t4[11] * t6[3] - t4[12] * t6[4] -
          t4[13] * t6[5] - t4[14] * t6[6] - t4[15] * t6[6],
      t4[0] * t6[4] + t4[1] * t6[3] - t4[2] * t6[6] - t4[4] * t6[1] +
          t4[8] * t6[0] - t4[10] * t6[2] + t4[11] * t6[4] + t4[12] * t6[3] -
          t4[13] * t6[6] + t4[14] * t6[5] + t4[15] * t6[5],
      t4[0] * t6[5] + t4[1] * t6[6] + t4[2] * t6[3] - t4[4] * t6[2] +
          t4[9] * t6[0] + t4[10] * t6[1] + t4[11] * t6[5] + t4[12] * t6[6] +
          t4[13] * t6[3] - t4[14] * t6[4] - t4[15] * t6[4],
      t4[3] * t6[3] - t4[5] * t6[4] - t4[6] * t6[5] - t4[7] * t6[6] +
          t4[11] * t6[0] + t4[12] * t6[1] + t4[13] * t6[2]);
}

template <>
inline Cir re(const Cir& cir, const Gld& gld) {
  const Gld& t1 = gld;
  const Cir& t2 = cir;
  Cir t3 = involute(t2);
  Mtt t4(t1[4] * t3[0] + t1[5] * t3[1] + t1[6] * t3[2],
         t1[2] * t3[9] - t1[3] * t3[0] + t1[5] * t3[2] - t1[6] * t3[1],
         -t1[1] * t3[9] - t1[3] * t3[1] - t1[4] * t3[2] + t1[6] * t3[0],
         t1[0] * t3[9] - t1[3] * t3[2] + t1[4] * t3[1] - t1[5] * t3[0],
         -t1[1] * t3[0] - t1[2] * t3[1], t1[0] * t3[0] - t1[2] * t3[2],
         t1[0] * t3[1] + t1[1] * t3[2],
         -t1[1] * t3[3] - t1[2] * t3[4] + t1[3] * t3[6] + t1[4] * t3[7] +
             t1[5] * t3[8] + t1[6] * t3[9],
         t1[0] * t3[3] - t1[2] * t3[5] + t1[3] * t3[7] - t1[4] * t3[6] -
             t1[5] * t3[9] + t1[6] * t3[8],
         t1[0] * t3[4] + t1[1] * t3[5] + t1[3] * t3[8] + t1[4] * t3[9] -
             t1[5] * t3[6] - t1[6] * t3[7],
         t1[0] * t3[6] + t1[1] * t3[7] + t1[2] * t3[8] + t1[4] * t3[0] +
             t1[5] * t3[1] + t1[6] * t3[2],
         t1[0] * t3[7] - t1[1] * t3[6] - t1[3] * t3[0] + t1[5] * t3[2] -
             t1[6] * t3[1],
         t1[0] * t3[8] - t1[2] * t3[6] - t1[3] * t3[1] - t1[4] * t3[2] +
             t1[6] * t3[0],
         t1[1] * t3[8] - t1[2] * t3[7] - t1[3] * t3[2] + t1[4] * t3[1] -
             t1[5] * t3[0],
         t1[0] * t3[2] - t1[1] * t3[1] + t1[2] * t3[0],
         t1[0] * t3[5] - t1[1] * t3[4] + t1[2] * t3[3] - t1[3] * t3[9] +
             t1[4] * t3[8] - t1[5] * t3[7] + t1[6] * t3[6]);
  const Gld& t5 = gld;
  Gld t6 = reverse(t5);
  return Cir(
      -t4[4] * t6[1] + t4[5] * t6[0] - t4[14] * t6[2],
      -t4[4] * t6[2] + t4[6] * t6[0] + t4[14] * t6[1],
      -t4[5] * t6[2] + t4[6] * t6[1] - t4[14] * t6[0],
      t4[0] * t6[4] + t4[1] * t6[3] - t4[2] * t6[6] + t4[3] * t6[5] -
          t4[7] * t6[1] + t4[8] * t6[0] + t4[10] * t6[4] + t4[11] * t6[3] -
          t4[12] * t6[6] + t4[13] * t6[5] - t4[15] * t6[2],
      t4[0] * t6[5] + t4[1] * t6[6] + t4[2] * t6[3] - t4[3] * t6[4] -
          t4[7] * t6[2] + t4[9] * t6[0] + t4[10] * t6[5] + t4[11] * t6[6] +
          t4[12] * t6[3] - t4[13] * t6[4] + t4[15] * t6[1],
      t4[0] * t6[6] - t4[1] * t6[5] + t4[2] * t6[4] + t4[3] * t6[3] -
          t4[8] * t6[2] + t4[9] * t6[1] + t4[10] * t6[6] - t4[11] * t6[5] +
          t4[12] * t6[4] + t4[13] * t6[3] - t4[15] * t6[0],
      t4[4] * t6[3] - t4[5] * t6[4] - t4[6] * t6[5] + t4[10] * t6[0] +
          t4[11] * t6[1] + t4[12] * t6[2] - t4[14] * t6[6],
      t4[4] * t6[4] + t4[5] * t6[3] - t4[6] * t6[6] + t4[10] * t6[1] -
          t4[11] * t6[0] + t4[13] * t6[2] + t4[14] * t6[5],
      t4[4] * t6[5] + t4[5] * t6[6] + t4[6] * t6[3] + t4[10] * t6[2] -
          t4[12] * t6[0] - t4[13] * t6[1] - t4[14] * t6[4],
      t4[1] * t6[2] - t4[2] * t6[1] + t4[3] * t6[0] - t4[4] * t6[6] +
          t4[5] * t6[5] - t4[6] * t6[4] - t4[14] * t6[3]);
}

}  // namespace vsr

#endif
